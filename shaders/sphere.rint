#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

#include "common.glsl"

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer SphereBuffer
{
	SpherePrimitive spheres[];
};

layout(shaderRecordEXT, std430) buffer ShaderRecord
{
	SphereBuffer sphere_buffer;
};

hitAttributeEXT vec3 sphere_point;

void main()
{
	SpherePrimitive sph = sphere_buffer.spheres[gl_PrimitiveID];
	vec3 orig = gl_WorldRayOriginEXT;
	vec3 dir = gl_WorldRayDirectionEXT;
	
	vec3 aabb_max = vec3(sph.aabb_maxx, sph.aabb_maxy, sph.aabb_maxz);
	vec3 aabb_min = vec3(sph.aabb_minx, sph.aabb_miny, sph.aabb_minz);
	vec3 center = (aabb_max + aabb_min) / vec3(2.0);
	float radius = (aabb_max.x - aabb_min.x) / 2.0;

	vec3 oc = orig - center;
	float a = dot(dir, dir);
	float b = dot(oc, dir);
	float c = dot(oc, oc) - radius * radius;
	float discr = b * b - a * c;

	float t = -1.0;

	if (discr >= 0.0) {
		const float t1 = (-b - sqrt(discr)) / a;
		const float t2 = (-b + sqrt(discr)) / a;
		bool first = (gl_RayTminEXT <= t1) && (t1 < gl_RayTmaxEXT);
		bool second = (gl_RayTminEXT <= t2) && (t2 < gl_RayTmaxEXT);
		if (first || second) {
			t = first ? t1 : t2;
		}
	}
	
	vec3 p = orig + t * dir;
	sphere_point = p;
	if (t > 0.0) 
		reportIntersectionEXT(t, 0);
}